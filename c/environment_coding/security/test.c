#include <stdio.h>
#include "hide_struct.h"

//就是说这里如果我知道了struct hide的结构,我就可以任意操作其成员,而这个在语言层次是没有办法防范的,归根结底就是语言没有(编译器)没有提供将结构和方法
//封装成一个整体的机制,而面向对象则通过private这样一些机制使得你不能去访问某些变量,即使你知道了结构组成,但是c++其实可以通过指针去访问成员,这方面感
//觉java做的要好一点,但java也可以通过类的重新赋值来获取.总之你把结构的定义暴露给别人了,就相当于开源了,所以不好防范访问私有变量是正常的.面向对象的防
//御是先例在闭源的基础上的.等等,java好像可以防御,因为我可以将类设成protected的,这样别人就没办法继承我,没办法赋值给我自定义的类没办法获取我这个对象
//的引用了.感觉java的引用和c的指针的区别在于:1.java的引用是hashcode,是java的内存布局(hashtable)的一个索引,而c的指针是系统中的虚拟地址(逻辑地址),更
//确切的说是逻辑地址中的偏移部分.所以指针从某种程度上是更加危险的东西,因为我可以通过指针的偏移去访问不该被你访问的东西,但它的好处是给程序员提供了更
//加强大的功能和更加灵活的变成方式,所以c语言更受黑客和底层人员的欣赏和喜欢,但也对编写安全的代码提出了更高的要求.而java的引用因为是一个hashcode,它只
//是所以一个大的hashtable的一个索引,而该索引的内容才是指向java内存堆中对象的指针(姑且这么称),所以其偏移并不具有逻辑性,这在损失灵活性的基础上提高了
//安全性.而且好像java也没有提供直接操作hashcode的方法,一般是通过对象的赋值来间接的操作,而且对象的赋值也只能发生在父类与子类,接口与实现之间.而且另一
//个重要的特性是c程序的内存布局具有连贯性,而java的内存布局的连贯性更弱一些
struct hack_hide{
	int flag;
};

int main(void){
	struct hide *hide = construct();
	setflag(hide,1);
	printf("%d\n",((struct hack_hide *)hide)->flag);
	return 0;
}
